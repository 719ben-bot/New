<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: cnx\\scroll.cnx</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>CNX\\SCROLL.CNX</h2>
<pre>
<b class="vimtag">*<a name="scroll.txt">scroll.txt</a>*</b>    For Vim version 7.4.  最近更新: 2010年7月


		     Vim 参考手册    作者: Bram Moolenaar
	   译者: iCrazy <code class="special">&lt;icrazy@ustc.edu&gt;</code>，tocer  http://vimcdoc.sf.net


滚屏						<b class="vimtag">*<a name="scrolling">scrolling</a>*</b>

这些命令是用来移动窗口中的内容的。如果光标的位置移出了窗口，那么它会带动窗口的
内容移动几行 (行数由 'scrolloff' 选项指定)，使光标回到窗口里。这里，我们定义一
页为窗口的行数减 2。下面这些命令的助记符甚易混淆。请记住这些命令所指的是视窗
(缓冲区中您可以看到的那一部分) 在缓冲区里向上移动还是向下移动。当窗口在缓冲区
里向上移动的时候，窗口中的文字朝您屏幕的下方移动。

请参阅用户手册的第 |<a href="usr_03.cnx#03.7">03.7</a>| 节，那里有一些介绍。

1. 向下滚屏			|<a href="scroll.cnx#scroll-down">scroll-down</a>|
2. 向上滚屏			|<a href="scroll.cnx#scroll-up">scroll-up</a>|
3. 相对于光标滚屏		|<a href="scroll.cnx#scroll-cursor">scroll-cursor</a>|
4. 水平滚动			|<a href="scroll.cnx#scroll-horizontal">scroll-horizontal</a>|
5. 同步滚屏			|<a href="scroll.cnx#scroll-binding">scroll-binding</a>|
6. 用鼠标滚轮滚屏		|<a href="scroll.cnx#scroll-mouse-wheel">scroll-mouse-wheel</a>|

</pre><hr><pre>1. 向下滚屏					<b class="vimtag">*<a name="scroll-down">scroll-down</a>*</b>

下面的这些命令使编辑视窗 (缓冲区中您可以看到的那一部分) 向下移动 (这样您就可以
看到缓冲区更多下方的文本行):

							<b class="vimtag">*<a name="CTRL-E">CTRL-E</a>*</b>
<code class="keystroke">CTRL-E</code>			使窗口在缓冲区中向下滚动 <code class="special">[count]</code> 行。
			助记: 额外 (Extra) 的行。

							<b class="vimtag">*<a name="CTRL-D">CTRL-D</a>*</b>
<code class="keystroke">CTRL-D</code>			使窗口在缓冲区中向下滚动。滚动的行数由 'scroll' 选项指
			定 (默认设置为半个屏幕)。如果指定了 <code class="special">[count]</code>，则会先把
			'scroll' 选项设为 <code class="special">[count]</code>。同时，光标试图在文件中向下
			移动相同的行数 (有行回绕或者碰到文件结束时行数会有差
			异) 。当光标处于缓冲区最后一行时，这个命令无效，并且系
			统会发出一声蜂鸣。
			参看 'startofline' 选项。
			助记: Downwards。
			{Vi: Vim 滚动 'scroll' 屏幕行，而不是文件行；有行回绕
			时两者会有差异}

<code class="special">&lt;S-Down&gt;</code>	或				<b class="vimtag">*<a name="%3CS-Down%3E">&lt;S-Down&gt;</a>*</b> <b class="vimtag">*<a name="%3CkPageDown%3E">&lt;kPageDown&gt;</a>*</b>
<code class="special">&lt;PageDown&gt;</code>	或				<b class="vimtag">*<a name="%3CPageDown%3E">&lt;PageDown&gt;</a>*</b> <b class="vimtag">*<a name="CTRL-F">CTRL-F</a>*</b>
<code class="keystroke">CTRL-F</code>			使窗口在缓冲区中向下滚动 <code class="special">[count]</code> 页。
			参看 'startofline' 选项。
			如果只有一个窗口，可能使用 'window' 选项的值。
			助记: Forwards。

							<b class="vimtag">*<a name="z+">z+</a>*</b>
z+			不指定 <code class="special">[count]</code>: 重绘，在窗口中显示下一页的内容 (使当前
			窗口之下的一行显示在窗口最上方)。同时把光标放在那一行
			第一个非空白字符上。
			指定 <code class="special">[count]</code>: 和 "z<code class="special">&lt;CR&gt;</code>" 一样。

</pre><hr><pre>2. 向上滚屏					<b class="vimtag">*<a name="scroll-up">scroll-up</a>*</b>

下面的这些命令使编辑视窗 (缓冲区中您可以看到的那一部分) 向上移动 (这样您就可以
看到缓冲区更多上方的文本行):

							<b class="vimtag">*<a name="CTRL-Y">CTRL-Y</a>*</b>
<code class="keystroke">CTRL-Y</code>			使窗口在缓冲区中向上滚动 <code class="special">[count]</code> 行。
			备注: 如果您使用 MS-Windows，组合键 <code class="keystroke">CTRL-Y</code> 会被重新映
			射为重做功能。

							<b class="vimtag">*<a name="CTRL-U">CTRL-U</a>*</b>
<code class="keystroke">CTRL-U</code>			使窗口在缓冲区中向上滚动。滚动的行数由 'scroll' 选项指
			定 (默认设置为半个屏幕)。如果指定了 <code class="special">[count]</code>，则会先把
			'scroll' 选项设为 <code class="special">[count]</code>。同时，光标试图在文件中向上
			移动相同的行数 (有行回绕或者碰到文件结束时 (译者注: 当
			为文件开始之误) 行数会有差异) 。当光标处于缓冲区第一行
			时，这个命令无效，并且系统会发出一声蜂鸣。
			参看 'startofline' 选项。
			助记: Upwards。
			{Vi: Vim 滚动 'scroll' 屏幕行，而不是文件行；有行回绕
			时两者会有差异}

<code class="special">&lt;S-Up&gt;</code>		或					<b class="vimtag">*<a name="%3CS-Up%3E">&lt;S-Up&gt;</a>*</b> <b class="vimtag">*<a name="%3CkPageUp%3E">&lt;kPageUp&gt;</a>*</b>
<code class="special">&lt;PageUp&gt;</code>	或					<b class="vimtag">*<a name="%3CPageUp%3E">&lt;PageUp&gt;</a>*</b> <b class="vimtag">*<a name="CTRL-B">CTRL-B</a>*</b>
<code class="keystroke">CTRL-B</code>			使窗口在缓冲区中向上滚动 <code class="special">[count]</code> 页。
			参看 'startofline' 选项。
			如果只有一个窗口，可能使用 'window' 选项的值。
			助记: Backwards。

							<b class="vimtag">*<a name="z^">z^</a>*</b>
z^			不指定 <code class="special">[count]</code>: 重绘，在窗口中显示上一页的内容 (使当前
			窗口之上的一行显示在窗口最下方)。同时把光标放在那一行
			第一个非空白字符上。
			指定 <code class="special">[count]</code>: 先滚动文本，使得缓冲区第 <code class="special">[count]</code> 行显示
			在窗口底部，然后重绘，使得当时处于窗口顶端的文本显示在
			窗口的底部。同时把光标放在那一行第一个非空白字符上。

</pre><hr><pre>3. 相对于光标滚屏				<b class="vimtag">*<a name="scroll-cursor">scroll-cursor</a>*</b>

以下的命令重新定位编辑视窗 (缓冲区中您可以看到的那一部分)，但仍维持光标留在当
前行。

							<b class="vimtag">*<a name="z%3CCR%3E">z&lt;CR&gt;</a>*</b>
z<code class="special">&lt;CR&gt;</code>			重绘，使第 <code class="special">[count]</code> 行显示在窗口顶端 (默认为光标所在的
			行)。光标停留在那一行第一个非空白字符上。

							<b class="vimtag">*<a name="zt">zt</a>*</b>
zt			类似 "z<code class="special">&lt;CR&gt;</code>"，不过光标停留在相同的列上。<code class="special">{Vi 无此功能}</code>

							<b class="vimtag">*<a name="zN%3CCR%3E">zN&lt;CR&gt;</a>*</b>
z<code class="special">{height}</code><code class="special">&lt;CR&gt;</code>		重绘，使得窗口有 <code class="special">{height}</code> 行高。当屏幕刷新速度很慢的时
			候，这对减少行数很有用。不能使窗口的高度超过屏幕的实际
			高度。

							<b class="vimtag">*<a name="z.">z.</a>*</b>
z.			重绘，使第 <code class="special">[count]</code> 行显示在窗口中部 (默认为光标所在的
			行)。光标停留在那一行第一个非空白字符上。

							<b class="vimtag">*<a name="zz">zz</a>*</b>
zz			类似 "z."，不过光标停留在相同的列上。注意: 如果打开了
			caps-lock，这个命令就变成了 "ZZ": 写缓冲区并退出！
			<code class="special">{Vi 无此功能}</code>

							<b class="vimtag">*<a name="z-">z-</a>*</b>
z-			重绘，使第 <code class="special">[count]</code> 行显示在窗口底部 (默认为光标所在的
			行)。光标停留在那一行第一个非空白字符上。

							<b class="vimtag">*<a name="zb">zb</a>*</b>
zb			类似 "z-"，不过光标停留在相同的列上。<code class="special">{Vi 无此功能}</code>

</pre><hr><pre>4. 水平滚动				<b class="vimtag">*<a name="scroll-horizontal">scroll-horizontal</a>*</b>

使用以下四个命令时，鼠标会跟随屏幕而移动。如果光标移出了屏幕，它就会落在屏幕中
距它最近的那个字符上。忽略 'sidescroll' 选项的值。

z<code class="special">&lt;Right&gt;</code>    或						<b class="vimtag">*<a name="zl">zl</a>*</b> <b class="vimtag">*<a name="z%3CRight%3E">z&lt;Right&gt;</a>*</b>
zl			使文本视图向右移动 <code class="special">[count]</code> 个字符，也就是使文本向左滚
			动 <code class="special">[count]</code> 个字符。仅当 'wrap' 为关时有效。
			<code class="special">{Vi 无此功能}</code>

z<code class="special">&lt;Left&gt;</code>      或						<b class="vimtag">*<a name="zh">zh</a>*</b> <b class="vimtag">*<a name="z%3CLeft%3E">z&lt;Left&gt;</a>*</b>
zh			使文本视图向左移动 <code class="special">[count]</code> 个字符，也就是使文本向右滚
			动 <code class="special">[count]</code> 个字符。仅当 'wrap' 为关时有效。
			<code class="special">{Vi 无此功能}</code>

							<b class="vimtag">*<a name="zL">zL</a>*</b>
zL			使文本视图向右移动半个屏幕宽度，也就是使文本向左滚动半
			个屏幕宽度。仅当 'wrap' 为关时有效。<code class="special">{Vi 无此功能}</code>

							<b class="vimtag">*<a name="zH">zH</a>*</b>
zH			使文本视图向左移动半个屏幕宽度，也就是使文本向右滚动半
			个屏幕宽度。仅当 'wrap' 为关时有效。<code class="special">{Vi 无此功能}</code>

以下两个命令仅仅在屏幕上滚动文本，光标不会移动。

							<b class="vimtag">*<a name="zs">zs</a>*</b>
zs			水平滚动文本，使光标置于屏幕的开始处 (最左侧)。仅当
			'wrap' 为关时有效。<code class="special">{Vi 无此功能}</code>

							<b class="vimtag">*<a name="ze">ze</a>*</b>
ze			水平滚动文本，使光标置于屏幕的结束处 (最右侧)。仅当
			'wrap' 为关时有效。<code class="special">{Vi 无此功能}</code>

</pre><hr><pre>5. 同步滚屏				<b class="vimtag">*<a name="scroll-binding">scroll-binding</a>*</b>

有时候，我们希望将两个或多个窗口绑在一起，这样，在一个窗口滚屏时，其他的窗口都
会跟着一起滚屏。在 Vim 中，可以通过设置针对不同窗口的 'scrollbind' 选项来达到
这个目的。当一个置位 'scrollbind' 选项的窗口滚屏时，其它置位 'scrollbind' 选项
的窗口会同步滚屏 (如果可能的话)。选项 'scrollbind' 的行为通过 'scrollopt' 选项
可以修改。

使用滚动条时进行滚动时，只有带焦点的窗口 (光标所在的窗口) 才会执行绑定。因而，
不用复位选项，您也可以在一段时间内避免滚动绑定的发生。

如果一个窗口还置位了 'diff' 选项，则滚屏绑定利用 2 个缓冲区中的差异来精确同步
它们的位置。否则，将会使用下面的方式:

							<b class="vimtag">*<a name="scrollbind-relative">scrollbind-relative</a>*</b>
每一个置位了 'scrollbind' 的窗口都会记录它的 "相对偏移"，可以把它看作当前窗口
和另一个窗口垂直滚屏位置上的差异。当一个置位了 'scrollbind' 的窗口被要求进行超
越其文本的开始和结束极限的滚屏时，这个窗口不再继续滚屏，但是它会记住超过极限的
数量。窗口记住了这些信息是为了将来能维持同样的相对偏移，不管是否曾经被要求过进
行超过其极限的滚屏。

但是，当一个置位了 'scrollbind' 且具有一个超过其缓冲区极限的相对偏移的窗口获得
了光标焦点的时候，其他置位了 'scrollbind' 的窗口就必须根据当前窗口的相对偏移，
跳转到相应的位置。这种行为可以通过清除 'scrollopt' 选项中的 'jump' 标志位来改
变。

						<b class="vimtag">*<a name="syncbind">syncbind</a>*</b> <b class="vimtag">*<a name=":syncbind">:syncbind</a>*</b> <b class="vimtag">*<a name=":sync">:sync</a>*</b>
:syncbind		强制所有 'scrollbind' 窗口具有相同的相对偏移。即: 当
			一个窗口滚屏到了它缓冲区的顶部时，所有的 'scrollbind'
			窗口都会滚屏到它们缓冲区的顶部。

							<b class="vimtag">*<a name="scrollbind-quickadj">scrollbind-quickadj</a>*</b>
当使用键盘命令来垂直的滚动一个窗口，或用垂直滚动条来滚动一个具有光标焦点的窗口
时， 'scrollbind' 标志是起作用的。但是，当用垂直滚动条来滚动一个不具有光标焦点
的窗口时，'scrollbind' 标志被忽略。这样就可以对 'scrollbind' 窗口的相对偏移量
进行快速的调整。

</pre><hr><pre>6. 用鼠标滚轮滚屏				<b class="vimtag">*<a name="scroll-mouse-wheel">scroll-mouse-wheel</a>*</b>

当您的鼠标有一个滚轮时，它在 GUI 方式下的 Vim 中应该可以正常工作。它怎么工作取
决于您的系统。它在 xterm 中也可能可以工作，参见: |<a href="scroll.cnx#xterm-mouse-wheel">xterm-mouse-wheel</a>|。缺省只支
持垂直滚轮，但有些 GUI 也支持横向滚轮。

Win32 GUI 的滚动功能是通过硬编码实现的。它的效果就像在拖曳当前窗口的滚动条。具
体滚多少行取决于您的鼠标驱动程序。如果滚屏功能造成了输入焦点的问题，请看:
|<a href="gui_w32.cnx#intellimouse-wheel-problems">intellimouse-wheel-problems</a>|。

而对 X11 GUI (Motif、Athena 和 GTK) 而言，滚动滚轮产生 <code class="special">&lt;ScrollWheelDown&gt;</code>、
<code class="special">&lt;ScrollWheelUp&gt;</code>、<code class="special">&lt;ScrollWheelLeft&gt;</code> 和 <code class="special">&lt;ScrollWheelRight&gt;</code> 的按键动作。这些键的
默认行为如下:
    <code class="special">&lt;ScrollWheelUp&gt;</code>	    向上滚动三行	<b class="vimtag">*<a name="%3CScrollWheelUp%3E">&lt;ScrollWheelUp&gt;</a>*</b>
    <code class="special">&lt;S-ScrollWheelUp&gt;</code>	    向上滚动一页	<b class="vimtag">*<a name="%3CS-ScrollWheelUp%3E">&lt;S-ScrollWheelUp&gt;</a>*</b>
    <code class="special">&lt;C-ScrollWheelUp&gt;</code>	    向上滚动一页	<b class="vimtag">*<a name="%3CC-ScrollWheelUp%3E">&lt;C-ScrollWheelUp&gt;</a>*</b>
    <code class="special">&lt;ScrollWheelDown&gt;</code>	    向下滚动三行	<b class="vimtag">*<a name="%3CScrollWheelDown%3E">&lt;ScrollWheelDown&gt;</a>*</b>
    <code class="special">&lt;S-ScrollWheelDown&gt;</code>	    向下滚动一页	<b class="vimtag">*<a name="%3CS-ScrollWheelDown%3E">&lt;S-ScrollWheelDown&gt;</a>*</b>
    <code class="special">&lt;C-ScrollWheelDown&gt;</code>	    向下滚动一页	<b class="vimtag">*<a name="%3CC-ScrollWheelDown%3E">&lt;C-ScrollWheelDown&gt;</a>*</b>
    <code class="special">&lt;ScrollWheelLeft&gt;</code>	    向左滚动六列	<b class="vimtag">*<a name="%3CScrollWheelLeft%3E">&lt;ScrollWheelLeft&gt;</a>*</b>
    <code class="special">&lt;S-ScrollWheelLeft&gt;</code>	    向左滚动一页	<b class="vimtag">*<a name="%3CS-ScrollWheelLeft%3E">&lt;S-ScrollWheelLeft&gt;</a>*</b>
    <code class="special">&lt;C-ScrollWheelLeft&gt;</code>	    向左滚动一页	<b class="vimtag">*<a name="%3CC-ScrollWheelLeft%3E">&lt;C-ScrollWheelLeft&gt;</a>*</b>
    <code class="special">&lt;ScrollWheelRight&gt;</code>	    向右滚动六列	<b class="vimtag">*<a name="%3CScrollWheelRight%3E">&lt;ScrollWheelRight&gt;</a>*</b>
    <code class="special">&lt;S-ScrollWheelRight&gt;</code>    向右滚动一页	<b class="vimtag">*<a name="%3CS-ScrollWheelRight%3E">&lt;S-ScrollWheelRight&gt;</a>*</b>
    <code class="special">&lt;C-ScrollWheelRight&gt;</code>    向右滚动一页	<b class="vimtag">*<a name="%3CC-ScrollWheelRight%3E">&lt;C-ScrollWheelRight&gt;</a>*</b>
它们应该适用于所有模式，编辑命令行时除外。

注意 仅当 'nowrap' 置位时横向滚动可用。此外，除非 'guioptions' 设置了 "h" 标志
位，如果光标行将要滚动到屏幕之外，移动光标到最长的可见行 (和横向滚动条的工作方
式类似)。

您可以通过键盘映射来改变缺省行为。例如，要使得普通模式下滚轮一次滚动一行或半
页:
<code class="example">   :map <code class="special">&lt;ScrollWheelUp&gt;</code> <code class="special">&lt;C-Y&gt;</code></code>
<code class="example">   :map <code class="special">&lt;S-ScrollWheelUp&gt;</code> <code class="special">&lt;C-U&gt;</code></code>
<code class="example">   :map <code class="special">&lt;ScrollWheelDown&gt;</code> <code class="special">&lt;C-E&gt;</code></code>
<code class="example">   :map <code class="special">&lt;S-ScrollWheelDown&gt;</code> <code class="special">&lt;C-D&gt;</code></code>
您也可以使用 Alt 和 Ctrl 修饰符。

自然，这些功能仅在 Vim 可以获取滚动事件时才可以使用。您可以使用 "xev" 程序来确
定这些是否功能有效。

当您使用 XFree86 时，文件 /etc/XF86Config 中必须有匹配您使用的鼠标的正确条目。
就 FreeBSD 来说，这个条目适用于一款罗技滚轮鼠标:
<code class="example">    Protocol     "MouseMan"</code>
<code class="example">    Device       "/dev/psm0"</code>
<code class="example">    ZAxisMapping 4 5</code>
欲了解更多的信息，请看 XFree86 的文档。

						<b class="vimtag">*<a name="%3CMouseDown%3E">&lt;MouseDown&gt;</a>*</b> <b class="vimtag">*<a name="%3CMouseUp%3E">&lt;MouseUp&gt;</a>*</b>
<code class="special">&lt;MouseDown&gt;</code> 和 <code class="special">&lt;MouseUp&gt;</code> 键已废弃。用 <code class="special">&lt;ScrollWheelUp&gt;</code> 来代替 <code class="special">&lt;MouseDown&gt;</code>，
<code class="special">&lt;ScrollWheelDown&gt;</code> 来代替 <code class="special">&lt;MouseUp&gt;</code>。

							<b class="vimtag">*<a name="xterm-mouse-wheel">xterm-mouse-wheel</a>*</b>
如前所述，您仅需要使滚轮鼠标在您的 Xserver 上工作正常，它就可以在一个新的
xterm 中工作。

为了在一个老的 xterm 中使用您的滚轮，您需要做以下工作:
1. 如前所述，使它在您的 Xserver 上工作正常。
2. 给 xterm 添加转换，使得 xterm 可以用转义序列 (escape sequence) 来传递一个滚
   屏事件。
3. 给 Vim 添加映射，来把这些转义序列解释为 <code class="special">&lt;ScrollWheelDown&gt;</code>、<code class="special">&lt;ScrollWheelUp&gt;</code>
   键。

把以下代码添加到您的 ~.Xdefaults 文件 (或者其他保存您 X 资源的文件) 中来进行转
换:
<code class="example"></code>
<code class="example">  XTerm*VT100.Translations:		#override \n\</code>
<code class="example">		s<code class="special">&lt;Btn4Down&gt;</code>: string("0x9b") string("[64~") \n\</code>
<code class="example">		s<code class="special">&lt;Btn5Down&gt;</code>: string("0x9b") string("[65~") \n\</code>
<code class="example">		<code class="special">&lt;Btn4Down&gt;</code>: string("0x9b") string("[62~") \n\</code>
<code class="example">		<code class="special">&lt;Btn5Down&gt;</code>: string("0x9b") string("[63~") \n\</code>
<code class="example">		<code class="special">&lt;Btn4Up&gt;</code>: \n\</code>
<code class="example">		<code class="special">&lt;Btn5Up&gt;</code>:</code>
<code class="example"></code>
把这些映射加到您的 vimrc 文件:
<code class="example">	:map <code class="special">&lt;M-Esc&gt;</code>[62~ <code class="special">&lt;ScrollWheelUp&gt;</code></code>
<code class="example">	:map! <code class="special">&lt;M-Esc&gt;</code>[62~ <code class="special">&lt;ScrollWheelUp&gt;</code></code>
<code class="example">	:map <code class="special">&lt;M-Esc&gt;</code>[63~ <code class="special">&lt;ScrollWheelDown&gt;</code></code>
<code class="example">	:map! <code class="special">&lt;M-Esc&gt;</code>[63~ <code class="special">&lt;ScrollWheelDown&gt;</code></code>
<code class="example">	:map <code class="special">&lt;M-Esc&gt;</code>[64~ <code class="special">&lt;S-ScrollWheelUp&gt;</code></code>
<code class="example">	:map! <code class="special">&lt;M-Esc&gt;</code>[64~ <code class="special">&lt;S-ScrollWheelUp&gt;</code></code>
<code class="example">	:map <code class="special">&lt;M-Esc&gt;</code>[65~ <code class="special">&lt;S-ScrollWheelDown&gt;</code></code>
<code class="example">	:map! <code class="special">&lt;M-Esc&gt;</code>[65~ <code class="special">&lt;S-ScrollWheelDown&gt;</code></code>

 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2014042</i></p>
</body>
</html>
