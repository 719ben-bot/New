<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: cnx\\usr_24.cnx</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>CNX\\USR_24.CNX</h2>
<pre>
<b class="vimtag">*<a name="usr_24.txt">usr_24.txt</a>*</b>	For Vim version 7.4.	最近更新: 2006年12月

		     VIM 用户手册 - Bram Moolenaar 著
		  译者:  Chimin Yen，tocer http://vimcdoc.sf.net

			      快速插入


输入文本时，Vim 提供你各种各样的方法来减少键击次数和避免打字错误。你可以利用插
入模式下的补全功能来重复先前打过的单词。也可以把长词缩写成短词。甚至可以打出你
键盘上没有的字符。

|<a href="usr_24.cnx#24.1">24.1</a>|	更正
|<a href="usr_24.cnx#24.2">24.2</a>|	显示匹配
|<a href="usr_24.cnx#24.3">24.3</a>|	补全
|<a href="usr_24.cnx#24.4">24.4</a>|	重复一次插入
|<a href="usr_24.cnx#24.5">24.5</a>|	从另一行拷贝
|<a href="usr_24.cnx#24.6">24.6</a>|	插入一个寄存器内容
|<a href="usr_24.cnx#24.7">24.7</a>|	缩写
|<a href="usr_24.cnx#24.8">24.8</a>|	插入特殊字符
|<a href="usr_24.cnx#24.9">24.9</a>|	二合字母
|<a href="usr_24.cnx#24.10">24.10</a>|	普通模式命令

       下一章: |<a href="usr_25.cnx#usr_25.txt">usr_25</a>|  编辑带格式的文本
       前一章: |<a href="usr_23.cnx#usr_23.txt">usr_23</a>|  编辑特殊文件
         目录: |<a href="usr_toc.cnx#usr_toc.txt">usr_toc</a>|

</pre><hr><pre><b class="vimtag">*<a name="24.1">24.1</a>*</b>	更正

退格键 <code class="special">&lt;BS&gt;</code> 已经在前面提过了。它删除位于光标前一格的字符。而删除键 <code class="special">&lt;Del&gt;</code> 则删
除光标下 (或者说光标后也可以) 的那个字符。
   当你把整个词都打错了的时候，用 <code class="keystroke">CTRL-W</code> 来更正:

<code class="section">	The horse had fallen to the sky </code>
				       <code class="keystroke">CTRL-W</code>
<code class="section">	The horse had fallen to the </code>

如果你把一行字弄得不可收拾，而要从头来过的话，用 <code class="keystroke">CTRL-U</code> 来删除。这个命令保留了
光标之后的文本，也保留了行首的缩进。它只删除了自第一个非空字符至光标位置之间的
文本。让光标位于下一行中 "fallen" 的 "f" 上，按 <code class="keystroke">CTRL-U</code>，文本就成了这样:

<code class="section">	The horse had fallen to the </code>
		      <code class="keystroke">CTRL-U</code>
<code class="section">	fallen to the </code>

当你发现几个词之前有个错误，你需要把光标移到那儿作更正。例如，你打了这样一行:

<code class="section">	The horse had follen to the ground </code>

你要把 "follen" 改成 "fallen"。让光标留在行尾，你输入这个字符串就能更正那错
误:
<code class="example"></code>
<code class="example">					<code class="special">&lt;Esc&gt;</code>4blraA</code>
<code class="example"></code>
	脱离插入模式			<code class="special">&lt;Esc&gt;</code>
	退回 4 个单词			     4b
	移到字母 "o" 上 		       l
	以字母 "a" 替代 			ra
	重新开始插入模式    			  A

另一种更正这个错误的方法:
<code class="example"></code>
<code class="example">		<code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code><code class="special">&lt;Right&gt;</code><code class="special">&lt;Del&gt;</code>a<code class="special">&lt;End&gt;</code></code>
<code class="example"></code>
	退回 4 个词		     <code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code><code class="special">&lt;C-Left&gt;</code>
	移到字母 "o" 上 			<code class="special">&lt;Right&gt;</code>
	删除字母 "o"				       <code class="special">&lt;Del&gt;</code>
	插入字母 "a"					    a
	移到行尾        				     <code class="special">&lt;End&gt;</code>

这种方法让你留在插入模式下，利用特殊键来移动光标。这类似于你在一个不分模式的编
辑器里所采用的操作方法。它比较容易记忆，但比较费事 (你必须把你的手从字母键移动
到光标方向键，而且，不看键盘难以按准 <code class="special">&lt;End&gt;</code> 键)。
   这些特殊键在书写一个停留在插入模式下的映射时非常有用。额外所需的键盘录入也
是值得的。
   你在插入模式下可以利用的特殊键有以下这些:

	<code class="special">&lt;C-Home&gt;</code>	移到文件首
	<code class="special">&lt;PageUp&gt;</code>	上卷一屏
	<code class="special">&lt;Home&gt;</code>		移到行首
	<code class="special">&lt;S-Left&gt;</code>	左移一个单词
	<code class="special">&lt;C-Left&gt;</code>	左移一个单词
	<code class="special">&lt;S-Right&gt;</code>	右移一个单词
	<code class="special">&lt;C-Right&gt;</code>	右移一个单词
	<code class="special">&lt;End&gt;</code>		移到行尾
	<code class="special">&lt;PageDown&gt;</code>	下卷一屏
	<code class="special">&lt;C-End&gt;</code>		移到文件尾

还有很多键，参见 |<a href="insert.cnx#ins-special-special">ins-special-special</a>|。

</pre><hr><pre><b class="vimtag">*<a name="24.2">24.2</a>*</b>	显示匹配

你键入一个右括号 ) 时，如果能知道它匹配哪个左括号 ( 会很方便。要让 Vim 做到这
点，用下面这个命令:
<code class="example"></code>
<code class="example">	:set showmatch</code>
<code class="example"></code>
现在你键入比如 "(example)" 这样几个字，当你键入右括号 ) 时，Vim 就把光标闪到匹
配的左括号 ( 上，在那儿停留半秒钟，然后返回原处。
   如果匹配的左括号不存在，Vim 就鸣起响铃。这样你就会想起来你可能在哪儿忘了一
个左括号，或键入了太多次的右括号。
   Vim 也会为 [] 和 <code class="special">{}</code> 这样的括号显示匹配。你不必等待光标返回原处才键入下一个
字符，只要下一个字符一键入，光标就会返回，而插入就会跟以前一样继续。
   你可以用 'matchtime' 选项改变 Vim 在匹配括号上停留的时间。例如，要让 Vim 等
待 1.5 秒:
<code class="example"></code>
<code class="example">	:set matchtime=15</code>
<code class="example"></code>
指定的时间以 1/10 秒为单位。

</pre><hr><pre><b class="vimtag">*<a name="24.3">24.3</a>*</b>	补全

Vim 能自动补全插入的单词。你键入一个单词的开头部分，按 <code class="keystroke">CTRL-P</code>，Vim 就会为你猜
测余下的部分。
   例如，假定你正在建立一个 C 程序，并要键入以下语句:

<code class="section">	total = ch_array[0] + ch_array[1] + ch_array[2]; </code>

你先输入下面这部分:

<code class="section">	total = ch_array[0] + ch_ </code>

此时，你用命令 <code class="keystroke">CTRL-P</code> 告诉 Vim 来补全这个词。Vim 就会搜索以光标前字符串开头的
词。在这个例子中，就是 "ch_"，与词 ch_array 匹配。所以，键入 <code class="keystroke">CTRL-P</code> 就会得到下
面的结果:

<code class="section">	total = ch_array[0] + ch_array </code>

再键入几个字符使这个语句变成这样 (结尾是空格):

<code class="section">	total = ch_array[0] + ch_array[1] +  </code>

如果你现在键入 <code class="keystroke">CTRL-P</code>，Vim 将再次搜索以补全光标前的词。由于光标前是空格，它找
到的是之前的第一个词，即 "ch_array"。再键入 <code class="keystroke">CTRL-P</code> 给你下一个匹配的词，在本例
中就是 "total"。第三次 <code class="keystroke">CTRL-P</code> 搜寻更前面的。如果那儿没其它的了，编辑器就会陷入
无词可配状态，所以搜索就返回原处，即那个空格。第四次 <code class="keystroke">CTRL-P</code> 导致编辑器周而复
始，又找到 "ch_array"。

往下搜索，用 <code class="keystroke">CTRL-N</code>。由于在文件结尾搜索又绕回开头，<code class="keystroke">CTRL-N</code> 和 <code class="keystroke">CTRL-P</code> 将找到相同
的匹配，但顺序不同。提示: <code class="keystroke">CTRL-N</code> 意为下一个匹配，而 <code class="keystroke">CTRL-P</code> 意为前一个匹配。
(译者: 英文 Next 意为下一个，Previous 意为前一个)

Vim 编辑器会非常努力的来补全不完整的词。默认情况下，它搜索如下一些地方:

	1.当前文件
	2.其它窗口内的文件
	3.其它载入文件 (隐藏缓冲区)
	4.未载入文件 (非激活缓冲区)
	5.标签文件
	6.被当前文件以 #include 语句包含的所有头文件


选 项

你可以利用 'complete' 选项定制搜索顺序。

还可以使用 'ignorecase' 选项。设定这个选项后，搜寻匹配时大小写的区别就会被忽
略。

一个特殊的补全选项是 'infercase'。它的用处是在寻找忽略大小写的匹配时
('ignorecase' 必须先被设定)，但仍然采用已键入部分的大小写。这样，如果你键入
"For" 而 Vim 找到了匹配 "fortunately"，所产生的结果将是 "Fortunately"。


补 全 特 定 文 本

如果你知道你要找什么，那么你可以用这些命令来补全某种类型的文本:

	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-F</code>		文件名
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-L</code>		整行
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-D</code>		宏定义 (包括包含文件里的)
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-I</code>		当前文件以及所包含的文件
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-K</code>		字典文件内的单词
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-T</code>		同义词词典文件内的单词
	<code class="keystroke">CTRL-X</code> CTRL-]		标签
	<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-V</code>		Vim 命令行

每个命令之后，<code class="keystroke">CTRL-N</code> 可以用来搜索下一个匹配，而 <code class="keystroke">CTRL-P</code> 则用于搜索前一个匹配。
   关于每个命令的详细用法，参见: |<a href="insert.cnx#ins-completion">ins-completion</a>|。


补 全 文 件 名

我们以 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-F</code> 为例。这个命令将找寻文件名。它在当前目录里搜索文件，并显
示每一个与光标前单词匹配的文件名。
   例如，假定你在当前目录里有下面这些文件:

	main.c  sub_count.c  sub_done.c  sub_exit.c

现在进入插入模式并开始键入:

<code class="section">	The exit code is in the file sub </code>

就在这点上，你输入 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-F</code>。现在，Vim 通过查看当前目录里的文件来补全当前
词 "sub"。最初的匹配是 sub_count.c。这不是你想要的，所以你按 <code class="keystroke">CTRL-N</code> 以匹配下一
个文件。这次匹配的是 sub_done.c。再键入 <code class="keystroke">CTRL-N</code> 给了你 sub_exit.c。结果:

<code class="section">	The exit code is in the file sub_exit.c </code>

如果文件名以 / (Unix) 或 C:\ (MS-Windows) 开头，那么你就能搜索文件系统下所有的
文件。例如，键入 "/u" 然后 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-F</code>，这将匹配 "/usr" (这是在 Unix 上):

<code class="section">	the file is found in /usr/ </code>

如果你现在按 <code class="keystroke">CTRL-N</code>，你就又回到 "/u"。接受 "/usr/" 并进入下一层目录，再来一次
<code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-F</code>:

<code class="section">	the file is found in /usr/X11R6/ </code>

当然，匹配结果取决于你的文件系统上有什么文件。匹配结果以字母顺序来排列。


补 全 源 代 码

源代码文件有良好的结构。这使通过某种智能方式补全成为可能。在 Vim 中，这被称为
全能补全。在其他编辑器中，它被称为智能补全(intellisense)，但这是一个注册商标。

全能补全的热键是 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-O</code>。显然，O 在这里代表全能 (Omni)，这样方便我们记
忆。让我们以编辑 C 程序为例:
<code class="example"></code>
<code class="example"><code class="section">	{ </code></code>
<code class="example"><code class="section">	    struct foo *p; </code></code>
<code class="example"><code class="section">	    p-&gt; </code></code>
<code class="example"></code>
光标在 "p-&gt;" 之后。现在键入 <code class="keystroke">CTRL-X</code> <code class="keystroke">CTRL-O</code>。Vim 会给你提供一个可选项的列表，这
些可选项为 "struct foo" 所拥有。这和使用 <code class="keystroke">CTRL-P</code> 有很大不同，后者补全任意单词，
而我们这里只要求 "struct foo" 的成员。

为使全能补全工作，需要做一些初始化。起码，要保证打开文件类型插件。你的 vimrc
文件应该包含形如:
<code class="example">	filetype plugin on</code>
或:
<code class="example">	filetype plugin indent on</code>
的一行。

对于 C 代码，需要建立标签文件并设置 'tags' 选项。在 |<a href="insert.cnx#ft-c-omni">ft-c-omni</a>| 中有进一步的解
释。对于其他文件类型，需要做类似的事情，请查看 |<a href="insert.cnx#compl-omni-filetypes">compl-omni-filetypes</a>|。补全只
对特定文件类型有效。查看 'omnifunc' 选项的值，以便检查补全能否正常工作。

</pre><hr><pre><b class="vimtag">*<a name="24.4">24.4</a>*</b>	重复一次插入

如果你按 <code class="keystroke">CTRL-A</code>，编辑器就把你上次在插入模式下输入的文本再输入一次。
   比如，假定你有个文件，开头是这样的:

<code class="section">	"file.h" </code>
	/<b class="vimtag">*<a name=" Main program begins "> Main program begins </a>*</b><code class="section">/ </code>

你在第一行开始处插入 "#include ":

<code class="section">	#include "file.h" </code>
	/<b class="vimtag">*<a name=" Main program begins "> Main program begins </a>*</b><code class="section">/ </code>

你再用命令 "j^" 往下来到下一行的开始处。现在你开始插入一个新的 "#include" 行。
所以你键入:
<code class="example"></code>
<code class="example">	i <code class="keystroke">CTRL-A</code></code>
<code class="example"></code>
结果就像下面这样:

<code class="section">	#include "file.h" </code>
	#include /<b class="vimtag">*<a name=" Main program begins "> Main program begins </a>*</b><code class="section">/ </code>

"#include " 被插入是因为 <code class="keystroke">CTRL-A</code> 会插入上次插入过的文本。现在你键入 "main.h"
<code class="special">&lt;Enter&gt;</code> 以结束这一行:


<code class="section">	#include "file.h" </code>
<code class="section">	#include "main.h" </code>
	/<b class="vimtag">*<a name=" Main program begins "> Main program begins </a>*</b><code class="section">/ </code>

CTRL-@ 命令会完成 <code class="keystroke">CTRL-A</code> 的操作后退出插入模式。这是一个快速重复插入一模一样的
文本的一个方法。

</pre><hr><pre><b class="vimtag">*<a name="24.5">24.5</a>*</b>	从另一行拷贝

<code class="keystroke">CTRL-Y</code> 命令插入光标上方的字符。当你复制前一行文本的时候，这个命令很有用。例
如，你有这么一行 C 代码:

<code class="section">	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; </code>

现在你需要把这一行再键入一次，并以 "s_prev" 取代 "s_next"。换行以后，按 14 次
<code class="keystroke">CTRL-Y</code>，直到光标位于 "next" 的 "n" 上:

<code class="section">	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;</code>
<code class="section">	b_array[i]-&gt;s_ </code>

现在你键入 "prev":

<code class="section">	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next; </code>
<code class="section">	b_array[i]-&gt;s_prev </code>

继续按 <code class="keystroke">CTRL-Y</code> 直到下一个 "next":

<code class="section">	b_array[i]-&gt;s_next = a_array[i]-&gt;s_next;</code>
<code class="section">	b_array[i]-&gt;s_prev = a_array[i]-&gt;s_ </code>

现在键入 "prev;" 以结束这一行。

<code class="keystroke">CTRL-E</code> 命令操作起来跟 <code class="keystroke">CTRL-Y</code> 一样，只不过它插入光标下方的字符。

</pre><hr><pre><b class="vimtag">*<a name="24.6">24.6</a>*</b>	插入一个寄存器内容

命令 <code class="keystroke">CTRL-R</code> <code class="special">{register}</code> 插入寄存器里的内容。它的用处是让你不必键入长词。例如，
你要输入下面这些:

<code class="section">	r = VeryLongFunction(a) + VeryLongFunction(b) + VeryLongFunction(c) </code>

这个函数的定义见于另一个文件。编辑那个文件并把光标移到该函数名上，然后把文件名
摄入寄存器 v:
<code class="example"></code>
<code class="example">	"vyiw</code>
<code class="example"></code>
"v 指定寄存器，"yiw" 意思是拷贝一个词，不含空格 (yank-inner-word)。现在编辑那
个要插入一行代码的文件，先键入开头几个字符:

<code class="section">	r = </code>

现在用 <code class="keystroke">CTRL-R</code> v 来插入函数名:

<code class="section">	r = VeryLongFunction </code>

你接下来在函数名后面键入其它必要字符，然后再用两次 <code class="keystroke">CTRL-R</code> v。
   你也可以用补全功能来完成同样的工作。但当你有好几个词，其开头几个字符都一样
的时候，寄存器就有用多了。

如果寄存器存放着诸如 <code class="special">&lt;BS&gt;</code> 或其它特殊字符，这些字符就被解释成好像它们本来是从键
盘键入的。如果你不要这样解释 (你确实要在文本中插入 <code class="special">&lt;BS&gt;</code>)，那么要命令 <code class="keystroke">CTRL-R</code>
<code class="keystroke">CTRL-R</code> <code class="special">{register}</code>。

</pre><hr><pre><b class="vimtag">*<a name="24.7">24.7</a>*</b>	缩写

缩写是取代一个长词的短词。例如，"ad" 指代 "advertisement"。Vim 让你键入缩写，
然后为你自动扩展。
   用以下命令告诉 Vim，每当你输入 "ad" 就把它扩展成 "advertisement":
<code class="example"></code>
<code class="example">	:iabbrev ad advertisement</code>
<code class="example"></code>
现在，当你键入 "ad"，完整的单词 'advertisement" 就被插入文本。键入一个不可能成
为单词一部分的字符，例如一个空格，就会触发缩写功能:

	输入的文本		看到的文本
<code class="section">	I saw the a		I saw the a </code>
<code class="section">	I saw the ad		I saw the ad </code>
<code class="section">	I saw the ad<code class="special">&lt;Space&gt;</code>	I saw the advertisement<code class="special">&lt;Space&gt;</code> </code>

当你仅仅键入 "ad" 时，扩展并没发生。它可以被你输入 "add" 这样的词而不被扩展。
Vim 只对那些完整的词检查缩写。


多 词 缩 写

为几个词定义一个缩写也是可能的。例如，用下面这个命令，把 "JB" 定义成 "Jack
Benny":
<code class="example"></code>
<code class="example">	:iabbrev JB Jack Benny</code>
<code class="example"></code>
作为程序员，我使用两个相当不寻常的缩写:
<code class="example"></code>
<code class="example">	:iabbrev #b /****************************************</code>
<code class="example">	:iabbrev #e <code class="special">&lt;Space&gt;</code>****************************************/</code>
<code class="example"></code>
它们用于生成大段注释。注释以缩写 #b 开始，划出顶线。接着，我键入注释文字，最后
以缩写 #e 划出底线。
   注意缩写 #e 以一个空格开头。换言之，开头两个字符是空格和星号 (*)。通常 Vim
忽略不计位于缩写及其扩展之间的空格。为了避免空格被忽略，我把空格以七个字符表
示: <code class="special">&lt;、S、p、a、c、e、&gt;</code>。

	备注:
	":iabbrev" 有点嫌长。":iab" 作用也一样。缩写命令被缩写了！


更 正 打 字 错 误

我们经常会犯同一个打字错误。例如，把 "the" 打成 "teh"。你可以利用缩写功能来更
正这样的错误:
<code class="example"></code>
<code class="example">	:abbreviate teh the</code>
<code class="example"></code>
你可以加上一系列这样的缩写。每次发现一个常见错误就加一个。


缩 写 列 表

":abbreviate" 命令列出所有缩写:

	:abbreviate
	i  #e		  ****************************************/
	i  #b		 /****************************************
	i  JB		 Jack Benny
	i  ad		 advertisement
	!  teh		 the

第一栏的 "i" 表明插入模式。这些缩写仅仅在插入模式下有作用。其它可能的字符:

	c	命令行模式      			:cabbrev
	!	插入模式和命令行模式            	:abbreviate

在命令行模式下使用缩写是不常见的。你主要会在插入模式下用 ":iabbrev" 命令。这样
就避免了不必要的扩展，例如，当你键入这样一条命令时，"ad" 就不会被扩展了:
<code class="example"></code>
<code class="example">	:edit ad</code>
<code class="example"></code>
<code class="example"></code>
删 除 缩 写

删除一个缩写，用 ":unabbreviate" 命令。假定你有以下缩写:
<code class="example"></code>
<code class="example">	:abbreviate @f fresh</code>
<code class="example"></code>
你可以用这个命令删除它:
<code class="example"></code>
<code class="example">	:unabbreviate @f</code>
<code class="example"></code>
当你键入这个命令的时候，你将注意到 @f 被扩展成 "fresh"。别担心，Vim 明白得很呢
(除非当你另有缩写 "fresh"，但那是很偶然的)。
   要删除全部缩写:
<code class="example"></code>
<code class="example">	:abclear</code>
<code class="example"></code>
":unabbreviate" 和 ":abclear" 另有变形，在插入模式下是 "iunabbreviate" 和
":iabclear"，在命令行模式下是 ":cunabbreviate" 和 "cabclear"。


缩 写 再 映 射

定义缩写时，有一点要注意的: 扩展产生的字符串不应当被映射成别的什么。例如:
<code class="example"></code>
<code class="example">	:abbreviate @a adder</code>
<code class="example">	:imap dd disk-door</code>
<code class="example"></code>
现在，你键入 @a，你得到 "adisk-doorer"。那不是你要的结果。为了避免这种事发生，
用 ":noreabbrev" 命令。它的作用跟 ":abbreviate" 一样，但却避免了扩展产生的字符
串被用于映射:
<code class="example"></code>
<code class="example">	:noreabbrev @a adder</code>
<code class="example"></code>
现在好了，缩写扩展后的结果不可能被映射了。

</pre><hr><pre><b class="vimtag">*<a name="24.8">24.8</a>*</b>	插入特殊字符

<code class="keystroke">CTRL-V</code> 命令用来插入下一个字面意义上的字符。换言之，无论该字符多特殊，其特殊含
义都被忽略不计。例如:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-V</code> <code class="special">&lt;Esc&gt;</code></code>
<code class="example"></code>
插入一个 <code class="special">&lt;Esc&gt;</code> 字符。而你并未脱离插入模式。(不要在 <code class="keystroke">CTRL-V</code> 后面键入空格，那个空
格仅仅为了方便阅读)。

	备注:
	在 MS-Windows 环境下，<code class="keystroke">CTRL-V</code> 用来粘贴文本。所以用 <code class="keystroke">CTRL-Q</code> 代替 <code class="keystroke">CTRL-V</code>。
	另外，在 Unix 环境下，<code class="keystroke">CTRL-Q</code> 在某些终端上不起作用，因其另有特殊意义。

你也可以用命令 <code class="keystroke">CTRL-V</code> <code class="special">{digits}</code> 来插入一个以若干个十进位数字 <code class="special">{digits}</code> 表示的字
符。例如，字符编码 127 是字符 <code class="special">&lt;Del&gt;</code> (但并不一定是 <code class="special">&lt;Del&gt;</code> 键！)。要插入 <code class="special">&lt;Del&gt;</code>，
键入:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-V</code> 127</code>
<code class="example"></code>
你可以用这样的方法输入数值不超过 255 的字符。当你键入一个不足两位的数字时，就
要添加一个非数字的字符来结束命令。为了回避这个非数字字符的要求，在它前面加一或
两个零以满足三位数的要求。
   以下命令都插入一个 <code class="special">&lt;Tab&gt;</code> 字符，然后一个点字符:

	<code class="keystroke">CTRL-V</code> 9.
	<code class="keystroke">CTRL-V</code> 09.
	<code class="keystroke">CTRL-V</code> 009.

输入一个 16 进制数字，在 <code class="keystroke">CTRL-V</code> 后面，用 "x" 开头:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-V</code> x7f</code>
<code class="example"></code>
这方法也可以用来输入数值不超过 255 (<code class="keystroke">CTRL-V</code> xff) 的字符。你可以用 "o" 开头输入
一个以 8 进制数表示的字符，以及另外两种方法，让你输入多至二进制 16 位和 32 位
的数字表示的字符 (例如，Unicode 字符):
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-V</code> o123</code>
<code class="example">	<code class="keystroke">CTRL-V</code> u1234</code>
<code class="example">	<code class="keystroke">CTRL-V</code> U12345678</code>
<code class="example"></code>
</pre><hr><pre><b class="vimtag">*<a name="24.9">24.9</a>*</b>	二合字母

有些字符在键盘上找不到。例如，表示版权的字符 (?) 要在 Vim 里键入这样的字符，你
得用二合字母，即以两个字符来表示一个。例如，要键入 ?， 你就得按三个键:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-K</code> Co</code>
<code class="example"></code>
你可以用以下命令来查找有哪些二合字母可供利用:
<code class="example"></code>
<code class="example">	:digraphs</code>
<code class="example"></code>
Vim 将把二合字母表显示在屏幕上。以下就是其中的三行:

<code class="section">  AC ~_ 159  NS |  160  !I ?  161  Ct ￠  162  Pd ￡  163  Cu ¤  164  Ye ￥  165 </code>
<code class="section">  BB |  166  SE §  167  ': ¨  168  Co ?  169  -a a  170  &lt;&lt; ?  171  NO ?  172 </code>
<code class="section">  -- -  173  Rg ?  174  'm ˉ  175  DG °  176  +- ±  177  2S 2  178  3S 3  179 </code>

这张表告诉你，比如，你键入 <code class="keystroke">CTRL-K</code> Pd 所得到的二合字母是字符 (￡)。该字符编码为
163 (十进制)。
   Pd 是 Pound (英镑) 的简写。大多数二合字母让你一看就猜到两个字符生成什么字
符。如果你一个个读下来，便不难理解其中的逻辑。
   你可以交换两个字符的顺序，只要那样组合不代表另一个二合字母。因此 <code class="keystroke">CTRL-K</code> dP
也没问题。由于 "dP" 不是二合字母，Vim 会转而搜索表示成 "Pd" 的二合字母。

	备注:
	二合字母表取决于 Vim 假定你所使用的字符集。在 MS-DOS 系统上采用的二合
	字母集不同于 MS-Windows 系统上的。务必用 ":digraphs" 命令来查找当前可
	供利用的二合字符。

你可以定义你自己的二合字母。例如:
<code class="example"></code>
<code class="example">	:digraph a" ?</code>
<code class="example"></code>
以上命令定义了 <code class="keystroke">CTRL-K</code> a" 插入一个 ? 字符。你也可以用十进值数指定这个字符。下面
这个命令定义了同一个二合字母:
<code class="example"></code>
<code class="example">	:digraph a" 228</code>
<code class="example"></code>
更多关于二合字母信息参见: |<a href="digraph.cnx#digraphs">digraphs</a>|
   另一种插入特殊字符的方法是利用键盘映射。详情参见: |<a href="usr_45.cnx#45.5">45.5</a>|

</pre><hr><pre><b class="vimtag">*<a name="24.10">24.10</a>*</b>	普通模式命令

插入模式提供的命令数量有限。在普通模式下，你可用的命令就多得多了。当你要用一个
普通模式命令时，你通常用 <code class="special">&lt;Esc&gt;</code> 键来脱离插入模式，执行这个普通模式命令，然后再
用 "i" 或 "a" 命令重新进入插入模式。
   有一个快捷的方法。用 <code class="keystroke">CTRL-O</code> <code class="special">{command}</code> 你可以在插入模式下执行任何普通模式命
令。例如，把光标后面直至行尾的文本删除:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-O</code> D</code>
<code class="example"></code>
用这个方法，你只能执行一个普通模式命令。但是，你可以指定一个寄存器或一个计数。
请看下面这个更复杂的命令:
<code class="example"></code>
<code class="example">	<code class="keystroke">CTRL-O</code> "g3dw</code>
<code class="example"></code>
这个命令把光标后面三个单词一起删除，存进了寄存器 g。

</pre><hr><pre>
下一章: |<a href="usr_25.cnx#usr_25.txt">usr_25</a>|  编辑带格式的文本

版权: 参见 |<a href="usr_01.cnx#manual-copyright">manual-copyright</a>|  vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 2014042</i></p>
</body>
</html>
